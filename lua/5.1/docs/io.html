<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="default.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
			<ul><li>
				<a href="index.html">index</a>
			</li></ul>
		<ul>
					<li><a href="coroutine.html">coroutine</a></li>
					<li><a href="debug.html">debug</a></li>
					<li><a href="global.html">global</a></li>
					<li>io</li>
					<li><a href="math.html">math</a></li>
					<li><a href="os.html">os</a></li>
					<li><a href="package.html">package</a></li>
					<li><a href="string.html">string</a></li>
					<li><a href="table.html">table</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>io</code></h1>
    Input and Output Facilities.
   <br/>The I/O library provides function for file manipulation.
 There are two different styles for file manipulation.
 The first one uses implicit file descriptors;
 that is, there are operations to set a default input file and a default output file,
 and all input/output operations are over these default files. 
 The second style uses explicit file descriptors.</p>

<p> When using implicit file descriptors, all operations are supplied by table io.</p>

<p> When using explicit file descriptors, the operation io.open returns a file descriptor
 and then all operations are supplied as methods of the file descriptor.</p>

<p> The table io also provides three predefined file descriptors with their usual meanings from C: io.stdin, io.stdout, and io.stderr.
 The I/O library never closes these files.</p>

<p> Unless otherwise stated, all I/O functions return nil on failure (plus an error message as a second result and a system-dependent error code as a third result)
 and some value different from nil on success.
			<h2><a id="#(file)">Type <code>file</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).close">file:close()</a></td>
		<td class="summary"> Closes <code>file</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).flush">file:flush()</a></td>
		<td class="summary"> Saves any written data to <code>file</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).lines">file:lines()</a></td>
		<td class="summary"> Returns an iterator function that, each time it is called, returns a
 new line from the file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).read">file:read(format)</a></td>
		<td class="summary"> Reads the file <code>file</code>, according to the given formats, which specify
 what to read.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).seek">file:seek(whence, offset)</a></td>
		<td class="summary"> Sets and gets the file position.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).setvbuf">file:setvbuf(mode, size)</a></td>
		<td class="summary"> Sets the buffering mode for an output file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(file).write">file:write(...)</a></td>
		<td class="summary"> Writes the value of each of its arguments to the <code>file</code>.</td>
		</tr>
	</table>

			<h2><a id="#(io)">Type <code>io</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).close">io.close(file)</a></td>
		<td class="summary"> Equivalent to <code>file:close</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).flush">io.flush()</a></td>
		<td class="summary"> Equivalent to <code>file:flush</code> over the default output file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).input">io.input(file)</a></td>
		<td class="summary"> When called with a file name, it opens the named file (in text mode),
 and sets its handle as the default input file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).lines">io.lines(a)</a></td>
		<td class="summary"> Opens the given file name in read mode and returns an iterator function
 that, each time it is called, returns a new line from the file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).open">io.open(filename, mode)</a></td>
		<td class="summary"> This function opens a file, in the mode specified in the string <code>mode</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).output">io.output(file)</a></td>
		<td class="summary"> Similar to <code>io.input</code>, but operates over the default output file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).popen">io.popen(prog, mode)</a></td>
		<td class="summary"> Starts program <code>prog</code> in a separated process and returns a file handle
 that you can use to read data from this program (if <code>mode</code> is <code>"r"</code>,
 the default) or to write data to this program (if <code>mode</code> is <code>"w"</code>).</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).read">io.read(format)</a></td>
		<td class="summary"> Equivalent to <code>io.input():read</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).stderr">io.stderr</a></td>
		<td class="summary"> io.stderr: Standard error.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).stdin">io.stdin</a></td>
		<td class="summary"> io.stdin: Standard in.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).stdout">io.stdout</a></td>
		<td class="summary"> io.stdout: Standard out.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).tmpfile">io.tmpfile()</a></td>
		<td class="summary"> Returns a handle for a temporary file.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="io.html##(io).write">io.write(...)</a></td>
		<td class="summary"> Equivalent to <code>io.output():write</code>.</td>
		</tr>
	</table>

			<h2>Type <code>file</code></h2>
				<h3>Field(s)</h3>
		<dl class="function">
<dt>
<a id="#(file).close" >
<strong>file:close()</strong>
</a>
</dt>
<dd>
	 Closes <code>file</code>.
	<br/>Note that files are automatically closed when their
 handles are garbage collected, but that takes an unpredictable amount of
 time to happen.
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(file).flush" >
<strong>file:flush()</strong>
</a>
</dt>
<dd>
	 Saves any written data to <code>file</code>.
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(file).lines" >
<strong>file:lines()</strong>
</a>
</dt>
<dd>
	 Returns an iterator function that, each time it is called, returns a
 new line from the file.
	<br/>Therefore, the construction</p>
<pre><code>for line in file:lines() do *body* end
</code></pre>
<p> will iterate over all lines of the file. (Unlike <code>io.lines</code>, this function
 does not close the file when the loop ends.)
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(file).read" >
<strong>file:read(format)</strong>
</a>
</dt>
<dd>
	 Reads the file <code>file</code>, according to the given formats, which specify
 what to read.
	<br/>
<p>For each format, the function returns a string (or a number)
 with the characters read, or nil if it cannot read data with the specified
 format. When called without formats, it uses a default format that reads
 the entire next line (see below).
 The available formats are</p>

<ul>
    <li><em>"*n"</em>: reads a number; this is the only format that returns a number
    instead of a string.</li>
    <li><em>"*a"</em>: reads the whole file, starting at the current position. On end of
    file, it returns the empty string.</li>
    <li><em>"*l"</em>: reads the next line (skipping the end of line), returning nil on
    end of file. This is the default format.</li>
    <li><em>number</em>: reads a string with up to this number of characters, returning
    nil on end of file. If number is zero, it reads nothing and returns an
    empty string, or nil on end of file.</li>
</ul>

		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				format  </em></code>: <em>"*n"</em>, <em>"*a"</em>, <em>"*l"</em> or a number.
				</li>
		</ul>
		<h3>Return value</h3>
				<p>
				A string (or a number) with the characters read, or nil if it cannot read data with the specified format.
				</p>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(file).seek" >
<strong>file:seek(whence, offset)</strong>
</a>
</dt>
<dd>
	 Sets and gets the file position.
	<br/>It is measured from the beginning of the
 file, to the position given by <code>offset</code> plus a base specified by the string
 <code>whence</code>, as follows:</p>

<ul>
    <li><code>"set"</code>: base is position 0 (beginning of the file);</li>
    <li><code>"cur"</code>: base is current position;</li>
    <li><code>"end"</code>: base is end of file;</li>
</ul>

<p> In case of success, function <code>seek</code> returns the final file position,
 measured in bytes from the beginning of the file. If this function fails,
 it returns nil, plus a string describing the error.
 The default value for <code>whence</code> is <code>"cur"</code>, and for <code>offset</code> is 0. Therefore,
 the call <code>file:seek()</code> returns the current file position, without changing
 it; the call <code>file:seek("set")</code> sets the position to the beginning of the
 file (and returns 0); and the call <code>file:seek("end")</code> sets the position
 to the end of the file, and returns its size.
		<h3>Parameters</h3>
		<ul>
				<li><code><em>
						#string
				whence  </em></code>:  <code>"set"</code>, <code>"cur"</code> or <code>"end"</code> (default value is <code>"cur"</code>)
				</li>
				<li><code><em>
						#number
				offset  </em></code>: offset of end position. (default value is 0)
				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
					<em>#number:</em>
				the final file position in bytes, if it succeed.
				</li>
				<li>
					<em>#nil, #string:</em>
				an error message, if it failed.
				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(file).setvbuf" >
<strong>file:setvbuf(mode, size)</strong>
</a>
</dt>
<dd>
	 Sets the buffering mode for an output file.
	<br/>There are three available
 modes:</p>

<ul>
    <li><code>"no"</code> : no buffering; the result of any output operation appears immediately.</li>
    <li><code>"full"</code> : full buffering; output operation is performed only when the
    buffer is full (or when you explicitly <code>flush</code> the file (see <code>io.flush</code>)).</li>
    <li><code>"line"</code> : line buffering; output is buffered until a newline is output or
    there is any input from some special files (such as a terminal device).</li>
</ul>

<p> For the last two cases, <code>size</code> specifies the size of the buffer, in
 bytes. The default is an appropriate size.
		<h3>Parameters</h3>
		<ul>
				<li><code><em>
						#string
				mode  </em></code>: the buffering mode : <code>"no"</code>, <code>"full"</code> or <code>"line"</code>.
				</li>
				<li><code><em>
						#number
				size  </em></code>: the size of the buffer.(default value is an appropriate size)
				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(file).write" >
<strong>file:write(...)</strong>
</a>
</dt>
<dd>
	 Writes the value of each of its arguments to the <code>file</code>.
	<br/>The arguments
 must be strings or numbers. To write other values, use <code>tostring</code> or
 <code>string.format</code> before <code>write</code>.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				...  </em></code>: must be strings or a numbers.
				</li>
		</ul>
</dd>
</dl>

			<h2>Type <code>io</code></h2>
				<h3>Field(s)</h3>
		<dl class="function">
<dt>
<a id="#(io).close" >
<strong>io.close(file)</strong>
</a>
</dt>
<dd>
	 Equivalent to <code>file:close</code>.
	<br/>Without a <code>file</code>, closes the default
 output file.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
						<a href="##(file)">#file</a>
				file  </em></code>: file to close.
				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).flush" >
<strong>io.flush()</strong>
</a>
</dt>
<dd>
	 Equivalent to <code>file:flush</code> over the default output file.
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).input" >
<strong>io.input(file)</strong>
</a>
</dt>
<dd>
	 When called with a file name, it opens the named file (in text mode),
 and sets its handle as the default input file.
	<br/>When called with a file
 handle, it simply sets this file handle as the default input file. When
 called without parameters, it returns the current default input file.</p>

<p> In case of errors this function raises the error, instead of returning an
 error code.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				file  </em></code>: a filename or a file handle which will used as default input. (optional)
				</li>
		</ul>
		<h3>Return value</h3>
				<p>
				<em><a href="##(file)">#file</a>:</em>
				the default input file handle.
				</p>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).lines" >
<strong>io.lines(a)</strong>
</a>
</dt>
<dd>
	 Opens the given file name in read mode and returns an iterator function
 that, each time it is called, returns a new line from the file.
	<br/>Therefore,
 the construction </p>
<pre><code>for line in io.lines(filename) do *body* end
</code></pre>
<p> will iterate over all lines of the file. When the iterator function detects
 the end of file, it returns nil (to finish the loop) and automatically
 closes the file.</p>

<p> The call <code>io.lines()</code> (with no file name) is equivalent to
 <code>io.input():lines()</code>; that is, it iterates over the lines of the default
 input file. In this case it does not close the file when the loop ends.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				a  </em></code>: filename or a file handle. (default value is <code>io.input()</code>)
				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).open" >
<strong>io.open(filename, mode)</strong>
</a>
</dt>
<dd>
	 This function opens a file, in the mode specified in the string <code>mode</code>.
	<br/>It
 returns a new file handle, or, in case of errors, nil plus an error message.
 The <code>mode</code> string can be any of the following:</p>

<ul>
    <li><em>"r"</em>: read mode (the default);</li>
    <li><em>"w"</em>: write mode;</li>
    <li><em>"a"</em>: append mode;</li>
    <li><em>"r+"</em>: update mode, all previous data is preserved;</li>
    <li><em>"w+"</em>: update mode, all previous data is erased;</li>
    <li><em>"a+"</em>: append update mode, previous data is preserved, writing is only
    allowed at the end of file.</li>
</ul>

<p> The <code>mode</code> string can also have a '<code>b</code>' at the end, which is needed in
 some systems to open the file in binary mode. This string is exactly what
 is used in the standard C function <code>fopen</code>.
		<h3>Parameters</h3>
		<ul>
				<li><code><em>
						#string
				filename  </em></code>: path to the file.
				</li>
				<li><code><em>
						#string
				mode  </em></code>: used to specify the open mode.
				</li>
		</ul>
		<h3>Return value</h3>
				<p>
				<em><a href="##(file)">#file</a>:</em>
				a file handle.
				</p>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).output" >
<strong>io.output(file)</strong>
</a>
</dt>
<dd>
	 Similar to <code>io.input</code>, but operates over the default output file.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				file  </em></code>: a filename or a file handle which will used as default output. (optional)
				</li>
		</ul>
		<h3>Return value</h3>
				<p>
				<em><a href="##(file)">#file</a>:</em>
				the default ouput file handle.
				</p>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).popen" >
<strong>io.popen(prog, mode)</strong>
</a>
</dt>
<dd>
	 Starts program <code>prog</code> in a separated process and returns a file handle
 that you can use to read data from this program (if <code>mode</code> is <code>"r"</code>,
 the default) or to write data to this program (if <code>mode</code> is <code>"w"</code>).
	<br/>This function is system dependent and is not available on all platforms.
		<h3>Parameters</h3>
		<ul>
				<li><code><em>
						#string
				prog  </em></code>: the program to start.
				</li>
				<li><code><em>
						#string
				mode  </em></code>: used to specify the open mode.
				</li>
		</ul>
		<h3>Return value</h3>
				<p>
				<em><a href="##(file)">#file</a>:</em>
				a file handle used to read from or write to the program <code>prog</code>.
				</p>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).read" >
<strong>io.read(format)</strong>
</a>
</dt>
<dd>
	 Equivalent to <code>io.input():read</code>.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				format  </em></code>: 


				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>
		<em><a href="##(file)">#file</a></em>
<a id="#(io).stderr" >
<strong>io.stderr</strong>
</a>
</dt>
<dd>
	 io.stderr: Standard error.
</dd>
</dl>
		<dl class="function">
<dt>
		<em><a href="##(file)">#file</a></em>
<a id="#(io).stdin" >
<strong>io.stdin</strong>
</a>
</dt>
<dd>
	 io.stdin: Standard in.
</dd>
</dl>
		<dl class="function">
<dt>
		<em><a href="##(file)">#file</a></em>
<a id="#(io).stdout" >
<strong>io.stdout</strong>
</a>
</dt>
<dd>
	 io.stdout: Standard out.
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).tmpfile" >
<strong>io.tmpfile()</strong>
</a>
</dt>
<dd>
	 Returns a handle for a temporary file.
	<br/>This file is opened in update
 mode and it is automatically removed when the program ends.
		<h3>Return value</h3>
				<p>
				<em><a href="##(file)">#file</a>:</em>
				a file handle for a temporary file.
				</p>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(io).write" >
<strong>io.write(...)</strong>
</a>
</dt>
<dd>
	 Equivalent to <code>io.output():write</code>.
		<h3>Parameter</h3>
		<ul>
				<li><code><em>
				...  </em></code>: 


				</li>
		</ul>
</dd>
</dl>

</div>

</div>
</body>
</html>
